fileVersion: 1
id: "1"
macroString: |-
  {# ----------------------------------------------------------------------
    Macro: buildcoldict
    Purpose: Builds a dictionary (ns.column_dict) of columns for all sources
  ---------------------------------------------------------------------- #}
  {% macro buildcoldict(ns) %}

      {% if sources is defined %}
          {% for source_idx in range(sources | length) %}
              {% set source = sources[source_idx] %}

              {# Initialize the source entry if missing #}
              {% if source_idx not in ns.column_dict %}
                  {% set _ = ns.column_dict.update({source_idx: {}}) %}
              {% endif %}

              {# Add all columns in this source to the dictionary #}
              {% for column in source.columns %}
                  {% set _ = ns.column_dict[source_idx].update({column.id: column}) %}
              {% endfor %}
          {% endfor %}

      {% endif %}
  {% endmacro %}

  {#--------------------------------------------------------
      The block of code below initializes variables for node types
      that use the advanced deployment strategy
  ----------------------------------------------------------#}
  {% if desiredState %}
      {% set columns = desiredState.columns %}
      {% set storageLocations = desiredState.storageLocations %}
      {% set config = desiredState.config %}
      {% set sources = desiredState.sources %}
      {% set node = desiredState.node %}
      {% set parameters = desiredState.parameters %}

      {% set ns = namespace(column_dict = {}) %}
      {# Populate column dictionary #}
      {{ buildcoldict(ns) }}

  {% endif %}

  {#-----------------------------------------------------------------
   	Macro: icebergcoldatatype
    	Purpose: Converts Snowflake column data types into their equivalent Iceberg-compatible types.
             - VARCHAR → STRING
             - TIMESTAMP → TIMESTAMP
             - TIME → TIME
             - Otherwise, passes through the original type.
  -------------------------------------------------------------------#}
  {% macro icebergcoldatatype( coldatatype ) %}

  	{% set nsVariables = namespace(ibcoldatatype = "") %}

  	{% if 'VARCHAR' in coldatatype %}
  		{% set nsVariables.ibcoldatatype = 'STRING' %}
  	{% elif 'TIMESTAMP' in coldatatype %}
  		{% set nsVariables.ibcoldatatype = 'TIMESTAMP' %}
  	{% elif 'TIME' in coldatatype %}
  		{% set nsVariables.ibcoldatatype = 'TIME' %}
  	{% else %}
  		{% set nsVariables.ibcoldatatype = coldatatype %}
  	{% endif %}
  	
  	{{ nsVariables.ibcoldatatype }}

  {% endmacro %}

  {# ----------------------------------------------------------------------
    Macro: dimensionHistoryPk
    Builds a composite key for dimension history:
     - Joins partition columns from partition_by('DIM')
     - Adds order_by_col() for uniqueness
     - Uses epoch millis or MD5(order_by_col) depending on record versioning
  ----------------------------------------------------------------------  #}
  {% macro dimensionHistoryPk() %}

      {%- set nsVariables = namespace(dimensionHistoryColumns = "") -%}
      {%- set partitionBy = partition_by('DIM').split("~") -%}
      {%- set orderBy = order_by_col() -%}

      {%- for col in partitionBy -%}
          {%- if loop.first -%}
              {%- set nsVariables.dimensionHistoryColumns = col -%}
          {%- else -%}
              {%- set nsVariables.dimensionHistoryColumns = nsVariables.dimensionHistoryColumns + ' || ' + '\'-\'' + ' ||' + col -%}
          {%- endif -%}
      {%- endfor -%}

      {% if config.recordVersioning not in ('Integer Column') %}
          {%- set nsVariables.dimensionHistoryColumns = nsVariables.dimensionHistoryColumns + ' || ' + '\'-\'' + ' || date_part(epoch_milliseconds, ' + orderBy + ')' -%}
      {% else %}
          {%- set nsVariables.dimensionHistoryColumns =  nsVariables.dimensionHistoryColumns ~ " || '-' || " ~ orderBy -%}
          {%- set nsVariables.dimensionHistoryColumns = "MD5(" ~ nsVariables.dimensionHistoryColumns ~")" -%}
      {% endif %}

      {{- nsVariables.dimensionHistoryColumns -}}

  {% endmacro %}

  {# ---------------------------------------------------------------------- 
    Macro: partition_by
    Purpose: Builds a partition key string for a node.
              - Uses '~' delimiter for DIM nodes, ',' otherwise.
              - Concatenates partitionBy config columns with proper transforms.
    Output: Returns the partition expression as a string.
  ----------------------------------------------------------------------  #}
  {% macro partition_by(nodetype) %}

      {# Create namespaces #}
      {% set nsVars = namespace(partition = "", delim = "") %}

      {# Choose delimiter based on node type #}
      {% if nodetype == 'DIM' %}
          {% set nsVars.delim = '~' %}
      {% else %}
          {% set nsVars.delim = ',' %}
      {% endif %}

      {# Build partition expression #}
      {% if config is defined and config.partitionBy is defined %}
          {% for item in config.partitionBy.get('items', []) %}
          
          {% set part_col = ns.column_dict[0][item.partColName.id] %}
          
          {%- if loop.first -%}
                  {%- set nsVars.partition = get_source_transform(part_col) -%}
              {%- else -%}
                  {%- set nsVars.partition = nsVars.partition + nsVars.delim + get_source_transform(part_col) -%}
              {%- endif -%}
          {% endfor %}
      {% endif %}

    {{ nsVars.partition }}

  {% endmacro %}

  {# ----------------------------------------------------------------------
    Macro: order_by_col
    Purpose: Returns the column expression used for ordering in record versioning.
     - If "Datetime Column": uses the configured datetime column.
     - If "Integer Column": uses the configured sequence column.
     - Otherwise: combines separate date and time columns into a timestamp.
    Output: Order-by column expression as a string.
    ----------------------------------------------------------------------#}
  {% macro order_by_col(return) %}

      {% set nsVariables = namespace(orderBy = "") -%}
    
      {% if config.recordVersioning in ('Datetime Column') -%}
          
          {% set datetimeColSort = config.orderBy.get('items', []) -%}		
          {% set dateTimeCol = ns.column_dict[0][datetimeColSort[0].colName.id] -%}        
          {% set nsVariables.orderBy = get_source_transform(dateTimeCol) -%}

  	{% elif config.recordVersioning in ('Integer Column')%}
          
          {% set datetimeNumericColSort = config.orderseq.get('items',[]) -%}
  	    {% set dateTimeCol = ns.column_dict[0][datetimeNumericColSort[0].colNameseq.id] -%}        
          {% set nsVariables.orderBy = get_source_transform(dateTimeCol) -%}
            
      {% else -%}

          {% set dateTimeColSort = config.orderByDateTime.get('items',[]) -%}
          {% set dateCol = ns.column_dict[0][dateTimeColSort[0].colNameDate.id] -%}
          {% set timeCol = ns.column_dict[0][dateTimeColSort[0].colNameTimestamp.id] -%}
          {% set nsVariables.orderBy = 'to_timestamp(' + get_source_transform(dateCol) +  '|| ' + '\'T\'' + ' ||' + get_source_transform(timeCol) +  ')' -%}
          
      {% endif -%}

      {{ nsVariables.orderBy }}

  {% endmacro %}

  {# ----------------------------------------------------------------------
    Macro: order_by_col_int
    Purpose:
      - Reads the configured "recordorderBy" column from the node settings.
      - Finds the matching column metadata by column ID.
   Output: Transformed column expression to be used in ORDER BY.
  ------------------------------------------------------------------------#}
  {% macro order_by_col_int(return) %}

      {% set nsVariables = namespace(orderBy = "") -%}

        {% set datetimeNumericColSort = config.recordorderBy.get('items',[]) %}
  	  {% set dateTimeCol = ns.column_dict[0][datetimeNumericColSort[0].ocolName.id] -%}    
        {% set nsVariables.orderBy = get_source_transform(dateTimeCol) -%} 
            
      {{ nsVariables.orderBy }}

  {% endmacro %}

  {#-- The below block of code initialises variables in case of node typess using advance deployment strategy #}

  {% if desiredState %}
      {% set columns = desiredState.columns %}
      {% set storageLocations = desiredState.storageLocations %}
      {% set config = desiredState.config %}
      {% set sources = desiredState.sources %}
      {% set node = desiredState.node %}
      {% set parameters = desiredState.parameters %}
  {% endif %}

  {#-- This macro will frame the order by clause with the columns and sort order specified in config #}
  {#-- Input parmeters   - None #}
  {#-- Return            - Order by clause #}

  {%- macro sortorder_by_colv(return) -%}
      {%- set nsVariables = namespace(sortcolNames="") -%}
      {%if config.orderby %}
          {%- for i in config.orderbycolumn.get('items') -%}
              {%- set colName = i.sortColName.name -%}
              {%- set colOrder = i.sortOrder -%}
  	        {%- if loop.first -%}	      
  		        {%- set nsVariables.sortcolNames = '"' + colName + '"' + colOrder -%}	  
  	        {%- else -%}      
  		        {%- set nsVariables.sortcolNames = nsVariables.sortcolNames + ',' + '"' + colName + '"' + colOrder-%}	  
  	        {%- endif -%}
          {%- endfor -%}	
              {%- set nsVariables.sortcolNames = 'order by' + nsVariables.sortcolNames -%}
   
      {% endif %} 
      
      {{- nsVariables.sortcolNames -}}
   
  {%- endmacro -%}

  {#-- The below block of code frmaes the partition by clause for qualify function #}
  {#-- Input parmeters   - None #}
  {#-- Return            - partition by clause #}

  {%- macro partition_by() -%}

      {%- set nsVariables = namespace(partition="") -%}
      {%- set sourceTableName = node.name -%}

      {%- for i in config.partitionBy.get('items') -%}
          {%- set colName = i.partColName.name -%}
          {%- if loop.first -%}
              {%- set nsVariables.partition = getSourceNameFromColumnName(colName) + '."' + colName + '"' -%}
          {%- else -%}
              {%- set nsVariables.partition = nsVariables.partition + ',' + getSourceNameFromColumnName(colName) + '."' + colName + '"' -%}
          {%- endif -%}

      {%- endfor -%}

      {{- nsVariables.partition -}}
  {%- endmacro -%}

  {%- macro getColumnId( colName ) -%}

      {%- set columnId = columns | selectattr('name','equalto',colName) | map(attribute='id') | first -%}

      {{- columnId -}}

  {%- endmacro -%}

  {% macro getSourceNameFromColumnName( colName ) %}

      {%- set sourceObject = sources[0].columns | selectattr('id','eq',getColumnId( colName )) | map(attribute='sourceColumns')  | first | map(attribute='node.name') | first -%}

      "{{- sourceObject -}}"

  {% endmacro %}


  {#-- This macro will split the join clause into from and rest of the clauses like where,groupby,orderby ,qualify  #}
  {#-- Input parmeters   - joinclause #}
  {#-- Return            - from clause and other clauses #}


  {%- macro get_clause( joinclause , ret_clause ) -%}

              {% set join_clause = joinclause %}
              {% set has_where_clause = 'where'in join_clause %}
              {% set has_WHERE_clause = 'WHERE'in join_clause %}
              {% set has_order_clause = 'order by'in join_clause %}
              {% set has_ORDER_clause = 'ORDER BY'in join_clause %}
              {% set has_group_clause =  'group by'in join_clause %}
              {% set has_GROUP_clause = 'GROUP BY'in join_clause %}
              {% set has_qualify_clause =  'qualify'in join_clause %}
              {% set has_QUALIFY_clause = 'QUALIFY'in join_clause %}

             

              {% set clause='default' %}

              {% if has_where_clause %}

                  {% set keyword='where'%} 
                  {% set clause='where_clause' %}
    
              {% elif  has_WHERE_clause %}

                   {% set keyword='WHERE'%}
                   {% set clause='where_clause' %}
              {% endif %}

              {% if has_group_clause and clause != 'where_clause'  %}

                   {% set keyword='group by'%}
                   {% set clause='group_clause' %}
              
              {% elif  has_GROUP_clause and clause != 'where_clause' %}

                   {% set keyword='GROUP BY'%}
                   {% set clause='group_clause' %}

              {% endif %}
  			
              {% if has_qualify_clause and clause != 'where_clause' and clause != 'group_clause'  %}

                   {% set keyword='qualify'%}
                   {% set clause='qualify_clause' %}
              
              {% elif  has_QUALIFY_clause and clause != 'where_clause' and clause != 'group_clause'  %}

                   {% set keyword='QUALIFY'%}
                   {% set clause='qualify_clause' %}

              {% endif %}            

  			{% if has_order_clause and  clause != 'where_clause' and clause != 'group_clause' and clause != 'qualify_clause' %}

                   {% set keyword='order by'%}
                   {% set clause='order_clause' %}
              
              {% elif has_ORDER_clause and clause != 'where_clause' and clause != 'group_clause' and clause != 'qualify_clause' %}

                   {% set keyword='ORDER BY'%}
                   {% set clause='order_clause' %}

              {% endif %}



              {% if clause == 'where_clause' %}
                 {% set parts = join_clause.split(keyword) %}
                 {% set from_clause = parts[0] %}
                 {% set add_clause = 'AND' + join_clause.split(keyword)[1] %}

              {% elif clause == 'group_clause' %}

                 {% set parts = join_clause.split(keyword) %}
                 {% set from_clause = parts[0] %}
                 {% set add_clause = 'group by' + join_clause.split(keyword)[1] %}

              
              {% elif clause == 'qualify_clause' %}

                 {% set parts = join_clause.split(keyword) %}
                 {% set from_clause = parts[0] %}
                 {% set add_clause = 'qualify' + join_clause.split(keyword)[1] %}


              {% elif clause == 'order_clause' %}

                 {% set parts = join_clause.split(keyword) %}
                 {% set from_clause = parts[0] %}
                 {% set add_clause =  'order by' + join_clause.split(keyword)[1] %}
                 

              {% else %}

                 {% set from_clause = join_clause %}
                 {% set add_clause = '' %}

              {% endif %}
  			
  			{% if ret_clause == 'from' %}
  			   {{ from_clause }}
  			{% else %}
  			   {{ add_clause }}
  			{% endif %}
  			
  			
  {%- endmacro -%}


  {%- macro ref_raw(location_name, node_name) -%}
      {%- raw -%}{{ ref('{% endraw %}{{- location_name }}{% raw %}', '{% endraw %}{{ node_name }}{% raw %}') }}{% endraw %}
  {%- endmacro -%}


  {%- macro ref_no_link_raw(location_name, node_name) -%}
      {% raw %}{{ ref_no_link('{% endraw %}{{ location_name }}{% raw %}', '{% endraw %}{{ node_name }}{% raw %}') }}{% endraw %}
  {%- endmacro -%}

  {#-- The below block of code initializes metadata changes variables for the display #}
  {#-- ===============================================================================#}
  {% macro update_metadata(tag, diff, label) %}
      {% set nsMetaVariables.metadataUpdate = nsMetaVariables.metadataUpdate + '-' + tag %}

      {# Handle metaDataChanges #}
      {% if nsMetaVariables.metaDataChanges %}
          {% set nsMetaVariables.metaDataChanges = nsMetaVariables.metaDataChanges ~ "\n\n" ~ label ~ " Changes:\n" ~ diff %}
      {% else %}
          {% set nsMetaVariables.metaDataChanges = label ~ " Changes:\n" ~ diff %}
      {% endif %}

  {% endmacro %}

  {###########################################################################################
  Purpose: Determines the correct Snowflake DROP object syntax based on the materialization type.
   
  Input: materialization (string): The Snowflake object type to be dropped
    (e.g., table, view, materialized view, dynamic table, external table).
   
  Returns: string: The appropriate DROP object keyword with IF EXISTS
    (e.g., 'table IF EXISTS', 'view IF EXISTS', 'materialized view IF EXISTS').
  #############################################################################################}
  {% macro dropMaterialization(materialization) %}
      {%- if materialization | lower in ['table', 'transient table','temporary table', 'hybrid table'] -%}
          TABLE IF EXISTS
      {%- elif materialization | lower in ['view', 'secure view', 'run view', 'cortex search service'] -%}
          VIEW IF EXISTS
      {%- elif materialization | lower in ['dynamic table','transient dynamic table', 'dynamic iceberg table'] -%}
          DYNAMIC TABLE IF EXISTS
      {%- elif materialization | lower == 'materialized view' -%}
          MATERIALIZED VIEW IF EXISTS
      {%- elif materialization | lower == 'external table' -%}
          EXTERNAL TABLE IF EXISTS
      {%- elif materialization | lower == 'iceberg table' -%}
          ICEBERG TABLE IF EXISTS
      {%- elif materialization | lower == 'interactive table' -%}
          INTERACTIVE TABLE IF EXISTS
      {%- elif materialization | lower == 'stream' -%}
          STREAM IF EXISTS
      {%- else -%}
          TABLE IF EXISTS
      {%- endif %}
  {% endmacro %}

  {###########################################################################################
  Purpose: Generates SQL-commented warnings or UI notifications when a user attempts to 
  change the Node Type or Materialization Type of a node. It identifies 
  critical node configurations (Tasks, Streams, Hybrid Views, Cortex, etc.) 
  that could lead to data loss or broken dependencies if switched.

  Input: None

  Returns: A string containing a SQL comment warning (starting with '-- ⚠️') 
      and/or triggers a stage-level warning UI notification for critical switches.
  #############################################################################################}
  {% macro getNodeTypeSwitchWarning() %}
      {%- if currentState.node.nodeType.split(':::')[-1] in ['300', '301'] -%}
          {# Current Node Type: Deferred Merge Nodes #}
          -- ⚠️ Warning: This table may be linked to hybrid views. Any required updates/drops must be handled manually.
      {%- elif currentState.node.nodeType.split(':::')[-1] in ['549', '550', '154', '155'] -%}
          {# Current Node Type: Root and Resume Tasks Nodes #}
          -- ⚠️ Warning: These node types are not ideal for switching, as they may act as root or resume tasks. Changing them may disrupt related tasks, cause inconsistencies, or result in data loss. Any required updates/drops must be handled manually.
      {%- elif currentState.node.materializationType | lower in ['task'] or currentState.node.nodeType.split(':::')[-1] in ['429', '567'] -%}
          {# Current Node Type: Tasks Related, Insert or Merge with Task, Document AI Nodes#}
          -- ⚠️ Warning: Tasks or streams are attached to this node. Changing its type may cause task failures, stream inconsistencies, or data loss. Any required updates/drops must be handled manually.
      {%- elif currentState.node.materializationType | lower in ['stream'] -%}
          {# Current Node Type: Stream Nodes #}
          -- ⚠️ Warning: This is a stream node. Changing its type may cause task failures, stream inconsistencies, or data loss. Any required updates/drops must be handled manually.
      {%- elif currentState.node.materializationType | lower in ['cortex search service'] -%}
          {# Current Node Type: Cortex Nodes #}
          -- ⚠️ Warning: Cortex search service is attached to this node. Changing its type may cause service failures, inconsistencies, or data loss. Any required updates/drops must be handled manually.
      {%- endif %}
  {% endmacro %}
name: macro
type: Macro
